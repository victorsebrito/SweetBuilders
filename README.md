# SweetBuilders

[![SweetBuilders NuGet Package](https://img.shields.io/nuget/v/SweetBuilders.svg)](https://www.nuget.org/packages/SweetBuilders/) [![SweetBuilders NuGet Package Downloads](https://img.shields.io/nuget/dt/SweetBuilders)](https://www.nuget.org/packages/SweetBuilders) [![GitHub Actions Status](https://github.com/victorsebrito/SweetBuilders/workflows/Build/badge.svg?branch=main)](https://github.com/victorsebrito/SweetBuilders/actions) [![codecov](https://codecov.io/gh/victorsebrito/SweetBuilders/branch/main/graph/badge.svg?token=aNLf6TFCJH)](https://codecov.io/gh/victorsebrito/SweetBuilders)

A generic implementation of the Builder Pattern for C#, for those who love syntactic sugar. Built on the top of [AutoFixture](https://github.com/AutoFixture/AutoFixture).

This library encapsulates AutoFixture's `Fixture.Build<T>()` method and gives you a straightforward API for you to build your objects exactly how you want. It also provides common, generic object factories and the ability to set private fields and properties.

# Getting started

Given the following classes `Foo` and `Bar`, see examples below:

```c#
public class Foo {
  
  public Foo() {
    Id = Guid.NewGuid().ToString();
  }

  public string Id { get; set; }
  public string? Prop1 { get; set; }
  public string? Prop2 { get; set; }
}

public class Bar {
  private string id;
  
  public Bar() {
    id = Guid.NewGuid().ToString();
  }

  public Foo? Foo { get; set; }
  public string? FooId { get; set; }
}
```

## Using `Builder<T>`

This is the fastest way to go. This class inherits the abstract class `BuilderBase<TObject, TBuilder>` and exposes 4 start points:

1. `Builder<T>.New` uses the default constructor of `T` (even if it's private)
```c#
var foo = Builder<Foo>.New
  .With(x => x.Prop1)
  .Create();

Console.WriteLine(foo.Id); // (Guid generated by the constructor)
Console.WriteLine(foo.Prop1); // (random value generated by AutoFixture)
Console.WriteLine(foo.Prop2); // null
```

2. `Builder<T>.Auto` enables auto properties and works just like calling `Fixture.Build<T>()`
```c#
var foo = Builder<Foo>.Auto
  .With(x => x.Prop1, "abc")
  .Create();

Console.WriteLine(foo.Id); // (Guid generated by the constructor)
Console.WriteLine(foo.Prop1); // abc
Console.WriteLine(foo.Prop2); // (random value generated by AutoFixture)
```

3. `Builder<T>.Uninitialized` will create an instance of `T` without using its constructors
```c#
var foo = Builder<Foo>.Uninitialized
  .With(x => x.Prop1, "abc")
  .Create();

Console.WriteLine(foo.Id); // null
Console.WriteLine(foo.Prop1); // abc
Console.WriteLine(foo.Prop2); // null
```

4. `Builder<T>.From(Func<T> factory)` will use the specified factory to create an instance of `T`
```c#
var foo = Builder<Foo>.From(() => new Foo())
  .With(x => x.Prop1, "abc")
  .Create();

Console.WriteLine(foo.Id); // (Guid generated by the constructor)
Console.WriteLine(foo.Prop1); // abc
Console.WriteLine(foo.Prop2); // (random value generated by AutoFixture)
```

## Setting private properties and fields

This feature is not supported by AutoFixture, but it's very useful in many scenarios.

1. Public properties with private sets

```c#
var foo = Builder<Foo>.New
  .WithPrivate(x => x.Id, "abc")
  .Create();

Console.WriteLine(foo.Id); // abc
```

2. Private properties and fields

```c#
var bar = Builder<Bar>.New
  .WithPrivate("id", "xyz")
  .Create();

// bar.id will be "abc"
```

## Creating a custom builder

You can inherit `BuilderBase<TObject, TBuilder>` to create your own custom builders with some default specific behaviors:

```c#
public class BarBuilder : BuilderBase<Bar, BarBuilder> {
  
  public BarBuilder()
    : base(Factories.Uninitialized<Bar>) { }

  public BarBuilder WithFoo(Foo foo) {
    With(x => x.Foo, foo);
    With(x => x.FooId, foo?.Id);
    return this;
  }
}

var foo = Builder<Foo>.New
  .With(x => x.Prop1, "abc")
  .Create();

var bar = new BarBuilder()
  .WithFoo(foo)
  .Create();

// bar.id will be null because it uses the uninitialized factory
Console.WriteLine(bar.Foo.Prop1); //abc
Console.WriteLine(bar.FooId); // (Guid generated by Foo's constructor)
```
